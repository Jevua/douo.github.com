---
title: 2015年06月17日杂记
date: '2015-06-17'
description:
tags:
- 深入理解计算机系统
widgets :
  math :
    enable : true
---

### 第一章

总览，主要有三个点

源文件，预处理器->读取头文件等等，编译器->汇编程序，汇编器->机器语言，最后链接器->链接其他提供函数调用的文件最后成为可执行文件

存储设备字塔结构，寄存器，L1，L2，L3高速缓存，内存，磁盘，网络。越高的存储设备越快，但越贵

操作系统，的几个主要概念，进程，线程，虚拟存储器，文件


### 第二章

##### 进制转换

2->10 :

```mathjax
2^w*b_i
```

10->2:

```mathjax
(a_w/2)= a_{w-1}...b_{w-1}\\
b_wb_{w-1}...b 
```

16->10:

```mathjax
16^w*b_i
```


##### 大小端

大小端，即字节序问题，一个字节序列构成一个数或者字符，读取这个字节顺序（最低有效位到最高有效位）应该由左往右读还是由右往左读。**最低有效位在最前面的方式（由左往右）叫小端法（little endian），最高有效位在最前面的方式（由右往左）叫大端法（big endian）。**

小端法与我们的阅读习惯相同。

##### C 语言中的位运算

- `~` 非
- `&` 与
- `|` 或
- `^` 异或 

##### 移位运算

- 逻辑左移，向左移位补零：  `[x_n-1,x_n-2,...,x_0]` << k = `[x_n-k-1,x_n-k-2,...,x_0,0,...,0]`
- 逻辑右移，向右移位补零：  `[x_n-1,x_n-2,...,x_0]` >> k = `[0,...,0,x_n-1,x_n-2,...,x_k]`
- 算术右移，向右移位补最高符号位： `[x_n-1,x_n-2,...,x_0]` >>> k = `[x_n-1,...,x_n-1,x_n-1,x_n-2,...,x_k]`

#### 整数

用

```mathjax
\vec x
```

表示二进制序列

无符号（unsigned）编码:

```mathjax
B2U_w(\vec x)=\sum_{i=0}^{w-1}x_i2^i
```

补码(two's-complement)编码

```mathjax
B2T_w(\vec x)=-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i
```


有符号与无符号的转换

```mathjax
B2U_w(\vec x) - B2T_w(\vec x) = 2^wx_{w-1}\\
B2U_w(\vec x) = B2T_w(\vec x) + 2^wx_{w-1}\\
\vec x = T2B_w(x)\\
B2U_w(T2B_w(x)) = x + 2^wx_{w-1}\\
```

当 `x_{w-1} 等于0，x>=0, T2U_w(x) = x`
当 `x_{w-1} 等于1，x<0, T2U_w(x) = x + 2^w`

位扩展

位截断


#### 整数运算

无符号加法

补码加法


#### 判断溢出

无符号整形:

```
//产生溢出时，溢出值肯定比加数小
int uadd_ok(unsigned x, unsigned y){
	if(x+y<x){
		return 0;
	}
	return 1;
}
```

补码溢出:

```
//补码溢出有两种情况，两个负数相加产生负溢出，结果为正数，两个正数相加产生正溢出，结果为负数
//检查符号位是否一致便可得出是否溢出
int tadd_ok(int x,int y){
	if(x>0&&y>0&&x+y<0){
		return 0;
	}else if(x<0&&y<0&&x+y>0){
		return 0；
	}else{
		return 1;
	}
}
```

#### 补码的非

`-x = ~x+1`

#### 乘法

无符号乘法，整数乘法的结果模2^w。

补码乘法，也是一样，可由无符号乘法推导出来。

乘以2的幂时，x*2k = x << k

乘以常数，将常数分解成为，多个2^a的项相加的和。可将乘法转换为多个加/减法和移位操作。

#### 除法


### 浮点数

IEEE 浮点表示


