---
title: 2015年05月16日杂记
date: '2015-05-16'
description:
tags:
- Android
- RecycleView
---

### ScrollingView

[ScrollingView | Android Developers](https://developer.android.com/reference/android/support/v4/view/ScrollingView.html)


### RecycleView 是什么

A flexible view for providing a limited window into a large data set.

ListView GridView 的代替者



- Adapter [RecyclerView.Adapter](https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter.html)
- Position, 数据在数据集的位置
- Index, ChildView 的位置 getChildAt(int)
- Binding, 绑定数据到界面的过程（Data.get(pos) -> getChildAt(idx)）
- Recycle(View)，回收，可复用的 View，处于刚刚显示完数据后暂时处于缓存中为接下来展示相同类型的数据做准备，避免了重复创建和填充界面的开销
- Scrap(View)，碎片，从 layout 中分离，接下来可能重用，也可能是标记为 dirty
- Dirty(View)，已经脏了的 View，必须经过重新计算才能显示出来


![](https://developer.xamarin.com/guides/android/platform_features/android_l/recyclerview/Images/04-view-recycling-sml.png)

1. When a view scrolls out of sight and is no longer displayed, it becomes a scrap view.
2. The scrap view is placed in a pool and becomes a recycle view. This pool is a cache of views that display the same type of data.
3. When a new item is to be displayed, a view is taken from the recycle pool for reuse. Because this view must be re-bound by the adapter before being displayed, it is called a dirty view.
4. The dirty view is recycled: the adapter locates the data for the next item to be displayed and copies this data to the views for this item. References for these views are retrieved from the view holder associated with the recycled view.
5. The recycled view is added to the list of items in the RecyclerView that are about to go on-screen.
6. The recycled view goes on-screen as the user scrolls the RecyclerView to the next item in the list. Meanwhile, another view scrolls out of sight and is recycled according to the above steps.

为什么要有 Adapter 和 LayoutManager

为什么要有不同的 Position

layout position，LayoutManager 视角中的位置
adapter position，最新数据集中的位置

考虑中动画中，数据集已经更新，而界面还未更新，这是可以通过这两个位置获得想要的数据


setChoiceMode(int) is gone

ViewHolder 负责单个 Item 的各种事件。

#### 数据更新

- DiffUtil，Myers差分算法，空间复杂度 O(N)，时间复杂度O(N + D^2)，N 列表项数量，D 是实际变更。DiffUtil.DiffResult 用于存放计算后的变更集（插入，移除，移动，更新）。禁用 move 检测可以提高效率，前提是列表有着固定的排序条件。

- SortedList 一个可变的有序列表，数据存放在一个数组中，添加元素时，回检测元素是否存在，是的话会触发更新通知，而不是添加通知。因为列表一直是有序的，使用不会触发 move

#### LayoutManager

Anchor position,

onLayoutChildren

1. find the  anchor position
2. calculate how many items should be in visible portion

scroll

small, only shift
large, recycle -> fill

- recycle,manager by a poll(shared across multiple recyclerview)
- scrap, manager by a heap. detachAndScrapAttachedViews

retrieve a view

- recycler.getViewForPosition(int)
- found in scrap，不用经过 adapter（very cheap）view 不用 created 和 rebind.
  use in re-attach in a same layout pass
- found in recycled pool，需要 rebind, adapter.bindViewHolder
- not found, adapter.createViewHolder

predictive animations

会在动画播放前预加载项

- pre-layout
- real-layout

wiresareobsolete.com/2014/09/building-a-recyclerview-layoutmanager-part-I

###　RecycleView　的应用

setHasFixedSize(true); 如果每个 item 都是固定大小的那设置这个可以提高效率



Scrollable View 的 Header 动画实现也不算太优雅，得通过 dummy header 实现
